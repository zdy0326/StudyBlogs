# 最短路径算法的代码总结

## 迪杰斯特拉算法 优先队列优化
```cpp
void solve() {
    int n, m;
    cin >> n >> m;
    
    int start = 1, end = n;
    vector<vector<pii>> adj(n + 1);

    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back({1, v});
        adj[v].push_back({1, u});
    }

    priority_queue<pii, vector<pii>, greater<pii>> pq;
    pq.push({0, start});
    vector<int> dis(n + 1, inf);
    dis[start] = 0;

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();

        if (d > dis[u]) continue;
        for (auto [w, v] : adj[u]) {
            if (dis[u] + w < dis[v]) {
                dis[v] = dis[u] + w;
                pq.push({dis[v], v});
            }
        }
    }

    if (dis[end] == inf) {
        cout << -1 << "\n";
    } else {
        cout << dis[end] << "\n";
    }
}
```

## 迪杰斯特拉算法 BFS版本

```cpp
void func() {
	int n, m;
	cin >> n >> m;
	
	vector<int> graph[5001];
	while (m--) {
		int u, v;
		cin >> u >> v;

		graph[u].push_back(v);
		graph[v].push_back(u);
	}

	vector<int> dis(5001, -1);
	queue<int> q;

	int start = 1;
	int end = n;

	dis[start] = 0;
	q.push(1);

	while (!q.empty()) {	
		int u = q.front();
		q.pop();

		for (auto v : graph[u]) {
			if (dis[v] == -1) {
				dis[v] = dis[u] + 1;
				q.push(v);
			}
		}
	}

	cout << dis[end] << "\n";

}
```

